# MIT 6.824 Lab notes
<hr/>

## <center> Lab1. MapReduce <center/>
<p align="right">2024.2.23<p>

ÂàöÊãøÂà∞‰ªªÂä°ÊèèËø∞ÂíåÈ°πÁõÆ‰ª£Á†ÅÔºåÂêÑÁßçRules, HintsÊª°Â§©È£ûÔºå‰∏ÄÊó∂ÊúâÁÇπÊó†‰ªé‰∏ãÊâã

ÁúãÊù•ÁúãÂéªÔºåÊàëÂÜ≥ÂÆö‰ªéÁ¨¨‰∏ÄÊù°hintÂºÄÂßãÔºöËÆ©workerÈÄöËøáRPCÂêëCoordinatorÂèëËØ∑Ê±Ç

Ê≥®ÊÑèÂà∞Ê∫êÁ†ÅÊèê‰æõ‰∫Ü`CallExample()`ÔºåÁÆÄÂçïÂ≠¶‰π†‰∫Ü‰∏Ä‰∏ãGOÁöÑRPCÊú∫Âà∂ÔºåÂÜçÁªìÂêàMapReduceË¶ÅÂÅöÁöÑ‰∫ãÔºåÂ§ß‰ΩìÊ°ÜÊû∂Â∞±ÈÄêÊ∏êÊ∏ÖÊô∞‰∫ÜÔºö`mrworker`ÂàõÂª∫Worker‰∏çÊñ≠Âêë`mrcoordinator`ÂàõÂª∫ÁöÑCoordinatorÂèëÈÄÅ‰ªªÂä°ËØ∑Ê±ÇÔºåCoordinatorÂ∞Ü‰ªªÂä°Ë¶ÅÊ±ÇÂíå‰ªªÂä°Êñá‰ª∂ËøîÂõûÔºåÊâÄÊúâ‰ªªÂä°ÂÆåÊàêÂêéÔºå`Coordinator.Done()`Â∞ÜËøîÂõû`true`Áªô`mrcoordinator`

È¶ñÂÖà‰ªéRPCÂÖ•Êâã

ÂÆö‰πâRPC‰ªªÂä°ËØ∑Ê±ÇÁªìÊûÑ`TaskRequest`Âíå‰ªªÂä°ÂõûÂ∫îÁªìÊûÑ`TaskReply`„ÄÇÊ≥®ÊÑèRPCÈÄö‰ø°Êó∂‰πüÂè™‰ºöÂèëÈÄÅÈ¶ñÂ≠óÊØçÂ§ßÂÜôÁöÑÂ≠óÊÆµ

```go
// Add your RPC definitions here.

type TaskRequest struct {
	Pid int
}

type TaskReply struct {
	TaskId   int
	TaskType string // map, reduce, exit, retry
	Filepath []string
	NReduce  int
}
```

Âèóhint 
> Depending on your design, you might also find it helpful to have a "please exit" pseudo-task that the coordinator can give to workers.

ÂêØÂèëÔºåÊàëÂÆö‰πâ‰∫Ü`exit`Âíå`retry`‰∏§‰∏™‰º™‰ªªÂä°Ôºå‰æø‰∫éworkerÈÄÄÂá∫

ÂÆåÊàê‰∫ÜÁÆÄÂçïÁöÑWorker helloÂíåCoordinator helloÂêéÔºå‰æøÊ≠£ÂºèÂºÄÂßãMapReduce„ÄÇ

### Èò∂ÊÆµ1 - Map

È¶ñÂÖàË¶ÅÂÆö‰πâCoordinatorÁöÑÂêÑ‰∏™Â≠óÊÆµÔºåÊàëÈíàÂØπmapÈò∂ÊÆµÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÁªìÊûÑ‰Ωì`MapTask`ÔºåÈáåÈù¢‰øùÂ≠ò‰∫ÜmapÈò∂ÊÆµÁöÑÊñá‰ª∂Êï∞„ÄÅÊñá‰ª∂Âêç„ÄÅ‰ªªÂä°Áä∂ÊÄÅÁ≠âÂ≠óÊÆµ‰ª•Âèä‰∏ÄÊääÈîÅÔºåÁ±ª‰ººÂêåÊ†∑ÂÆö‰πâ‰∏Ä‰∏™`ReduceTask`ÁªìÊûÑ‰ΩìÔºàÂ•ΩÂÉèÂèØ‰ª•Â§çÁî®Âì¶ÔºàÈÄÉÔºâ

```go
type Coordinator struct {
	// Your definitions here.
	nReduce int
	taskNum int

	mtask MapTask
	rtask ReduceTask
}

type MapTask struct {
	lock      sync.Mutex
	fileNum   int
	filenames []string
	mstate    []int // states of M map tasks
	done      bool
}

type ReduceTask struct {
	lock      sync.Mutex
	reduceNum int
	filenames []string
	rstate    []int // states of R reduce tasks
	done      bool
}
```

ÈòÖËØªÊ°ÜÊû∂‰ª£Á†ÅÂèëÁé∞Ôºåcoordinator.go‰ªé`MakeCoordinator(files []string, nReduce int)`ÂºÄÂßãË¢´Ë∞ÉÁî®ÔºåÂàùÂßãÂåñËØªÂèñ‰ªªÂä°Êñá‰ª∂Á≠âÊï∞ÊçÆÔºåÊ≥®ÂÜåÂêØÂä®RPCÊúçÂä°ÂêéÔºåCoordinatorÂ∞±ËÉΩÂºÄÂßãÂìçÂ∫îWorkerËØ∑Ê±Ç‰∫Ü

‰∫éÊòØÊàëÊ≥®ÂÜå‰∫Ü‰∏Ä‰∏™`Coordinator.AssignTask`ÊñπÊ≥ïÔºåÈõèÂΩ¢Â¶Ç‰∏ã

Â¶ÇÊûúmapÈò∂ÊÆµËøòÊú™ÁªìÊùüÔºåÈÇ£‰πàÂ∞±ÂàÜÈÖçmap‰ªªÂä°ÔºåÁî±`assignMap()`ÂØªÊâæÁ©∫Èó≤ÁöÑmap taskÂπ∂ËøîÂõû`mapid`ÔºåÂπ∂Â∞ÜËøô‰∏™‰ªªÂä°ËøîÂõûÁªôworkerÔºåÁöÜÂ§ßÊ¨¢Âñú


```go
// Prototype, uncompleted
func (c *Coordinator) AssignTask(reqst *TaskRequest, reply *TaskReply) error {
    ...
	mdone := c.mapDone()
	rdone := c.reduceDone()

	// Check if all map tasks done
	if !mdone {

		c.mtask.lock.Lock()
		mapid := c.assignMap()

		// All map tasks assigned or done, please wait
		if mapid == -1 {
			c.mtask.lock.Unlock()
            ...
			return nil
		}

		// Assign a map task
		reply.TaskType = "map"
		reply.TaskId = mapid
		reply.Filepath = append(reply.Filepath, c.mtask.filenames[mapid])
		c.mtask.mstate[mapid] = ASSIGNED

		c.mtask.lock.Unlock()

		// Check timeout
		go func() {
            ...
        }

	} else if !rdone {
        // Assign reduce task
        ...
	} else {
        // Pseudo-task
		reply.TaskType = "exit"
	}
	return nil
}

//
//	Not re-entrant, must hold c.mtask.lock when access
//	return -1 when all map tasks done or assigned
//
func (c *Coordinator) assignMap() int {
	flag := true
	for i, status := range c.mtask.mstate {
		if status == UNASSIGNED || status == TIMEDOUT {
            // üëá Just assign this task 
			return i
		}
		flag = flag && (status == DONE)
	}

	if flag {
		// Map task done
		c.mtask.done = flag
	} else {
		// All assigned
		c.disable()
	}
	return -1
}

```

Â¶ÇÊûú`assignMap()`ËøîÂõû-1ÔºåË¶Å‰πàÂ∞±ÊòØmap‰ªªÂä°ÂàÜÈÖçÂÆå‰∫ÜÔºåË¶Å‰πàÂ∞±ÊòØmapÈò∂ÊÆµÁªìÊùü‰∫ÜÔºå‰∏çÁÆ°ÊÄéÊ†∑ÔºåËøô‰∏™workerÈÉΩË¶ÅÂõûÂéªÁ≠âÈÄöÁü•

ÁÆÄÂçïÁöÑÂÆûÁé∞Â∞±ÊòØËøîÂõû‰∏Ä‰∏™"wait"‰º™‰ªªÂä°ÔºåËÆ©workerËøîÂõûËá™Â∑±ÁöÑÁ∫øÁ®ãÁù°‰∏âÁßíÂÜçÊù•ËØ∑Ê±Ç
```go
    // Coordinator:
        ...
		// All map tasks assigned or done, please wait
		if mapid == -1 {
			reply.TaskType = "wait"
			c.mtask.lock.Unlock()
			return nil
		}
        ...
    // Worker:
        ...
        case "wait":
        time.Sleep(3 * time.Second)
        continue
        ...
```
ËøôÁßçÊñπÊ≥ïÁÆÄÂçïÊúâÊïàÔºå‰∏çÊòìÂá∫ÈîôÔºåÁº∫ÁÇπÊòØÂú®Âπ≥Âùá‰ªªÂä°Êó∂Èó¥Ëä±Ë¥πÂæàÁü≠Êó∂Ôºå‰ºöËÆ©workerÁù°Áú†ËøáÈïøÔºåÈôç‰ΩéÊïàÁéá„ÄÇÂú®ÊâÄÊúâÊµãËØïÈÄöËøáÂêéÔºåÊàëÂ∞ÜÂÖ∂‰ºòÂåñ‰∏∫‰∫ÜÊù°‰ª∂ÂèòÈáèÂÆûÁé∞

```go
        ...
		// All map tasks assigned or done, please wait
		if mapid == -1 {
			c.mtask.lock.Unlock()

			c.gotoSleep(reqst.Pid)
			reply.TaskType = "retry"
			return nil
		}
        ...
}
//
//	Put the worker to sleep when no available tasks
//
func (c *Coordinator) gotoSleep(wid int) {
	c.cond.L.Lock()
	if !c.available {
		fmt.Printf("Put worker %v to sleep\n", wid)
		c.cond.Wait()
	}
	c.cond.L.Unlock()
	fmt.Printf("Worker %v awakened\n", wid)
}
```

Êé•‰∏ãÊù•ËÄÉËôëWorkerÂÆåÊàê‰ªªÂä°Êó∂ÈÄöÁü•Coordinator

ÂÆö‰πâRPCÈÄö‰ø°ÁªìÊûÑ‰Ωì`TaskNotice`Âπ∂Ê≥®ÂÜåÊúçÂä°`Coordinator.NoticeTaskDone`

ÂΩìWorkerÂÆåÊàê‰ªªÂä°ÂêéËøîÂõû‰ªªÂä°‰ø°ÊÅØÂíåËæìÂá∫Êñá‰ª∂Ë∑ØÂæÑÔºàhintÊèêÂà∞ÔºöÊú¨lab‰∏≠Âõ†‰∏∫masterÂíåworkerÂú®Âêå‰∏ÄÂè∞Êú∫Âô®‰∏äÔºåÊâÄ‰ª•ÂèØ‰ª•Áõ¥Êé•ËØªÂèñÊñá‰ª∂Ôºå‰ΩÜÊòØÂú®ÂàÜÂ∏ÉÂºèÊÉÖÂÜµ‰∏ãÔºåÈúÄË¶Å‰∏Ä‰∏™ÂÖ®Â±ÄÊñá‰ª∂Á≥ªÁªüÔºå‰æãÂ¶ÇGFSÔºâ

CoordinatorÊî∂Âà∞ÈÄöÁü•Âêé‰øÆÊîπÂØπÂ∫î‰ªªÂä°ÁöÑÁä∂ÊÄÅÔºåÂπ∂‰øùÂ≠ò‰∏≠Èó¥Êñá‰ª∂Âà∞`ReduceTask`Â§áÁî®ÔºåÈ°∫‰æøÂà§Êñ≠‰∏Ä‰∏ãÊâÄÊúâmap‰ªªÂä°ÊòØÂê¶ÈÉΩÂÆåÊàê‰∫ÜÔºåÊòØÁöÑËØùÂ∞±ÂèØ‰ª•‰øÆÊîπ`c.mtask.done = true`ÔºåËøõÂÖ•reduceÈò∂ÊÆµ

```go
type TaskNotice struct {
	TaskId    int
	TaskType  string   // map, reduce
	OFilepath []string // output file
}
//
//	Notice coordinator that the task assigned was done by worker
//
func (c *Coordinator) NoticeTaskDone(notice *TaskNotice, reply *TaskReply) error {
	switch notice.TaskType {
	case "map":
		fmt.Printf("> Map task %v done from worker\n", notice.TaskId)

		c.mtask.lock.Lock()

		c.mtask.mstate[notice.TaskId] = DONE
		c.mtask.fileNum--

		// Add to reduce tasks
		c.rtask.lock.Lock()
		c.rtask.filenames = append(c.rtask.filenames, notice.OFilepath...)
		c.rtask.lock.Unlock()

		if c.mtask.fileNum == 0 {
			c.mtask.done = true
			fmt.Printf(">> Coordinator: All map tasks done.\n")
			fmt.Printf("Waking up all workers...\n")
			c.mtask.lock.Unlock()
			// wake up all sleeping workers
			c.enable()
			c.cond.Broadcast()
		} else {
			c.mtask.lock.Unlock()
		}

	case "reduce":
		...
	}
	return nil
}
```
`c.cond.Broadcast()`‰πüÊòØÂØπÂ∫îÁöÑÊù°‰ª∂ÂèòÈáè‰ºòÂåñÔºåÁî®Êù•Âî§ÈÜíÂâçÈù¢ÊèêÂà∞ÁöÑÂÖ•Áù°ÁöÑworker„ÄÇÂ¶ÇÊûúÊòØÁÆÄÂçïÁöÑÂçïÁ∫øÁ®ãÁ≠âÂæÖ‰∏âÁßíÂÆûÁé∞ÔºåÂ∞±‰∏çÈúÄË¶ÅÂî§ÈÜí

ËøôÊ†∑CoordinatorËøôËæπÂ∞±Ââ©‰∏Ä‰∏™ÂÖ≥ÈîÆÈóÆÈ¢òÔºöworkerË∂ÖÊó∂„ÄÇËÆ∫ÊñáÊèêÂà∞ÔºåÂ¶ÇÊûúÂá∫Áé∞slow workerÊàñËÄÖworkerÂÆïÊú∫ÔºåÂàÜÈÖçÁªôËøô‰∏™workerÁöÑ‰ªªÂä°Â∞±Ë¶ÅÂÖ®ÈÉ®‰∫§ÁªôÂÖ∂‰ªñworkerÈáçÂÅö„ÄÇ

È¢òÁõÆÁªôÂá∫ÁöÑË∂ÖÊó∂Êó∂Èó¥ÊòØ10ÁßíÔºåÂú®ÂàÜÈÖç‰∫Ü‰∏Ä‰∏™‰ªªÂä°ÂêéÔºåÂà©Áî®`go`ÂéüËØ≠ÂíåÂåøÂêçÂáΩÊï∞ÔºåÂèØ‰ª•ÂæàÊñπ‰æøÂú∞ÂàõÂª∫‰∏Ä‰∏™Ê£ÄÊü•Á∫øÁ®ãÔºåÂú®10ÁßíÂêéÊ£ÄÊü•ËØ•‰ªªÂä°Áä∂ÊÄÅ

```go
	if !mdone {	

		...

		// Assign a map task
		reply.TaskType = "map"
		reply.TaskId = mapid
		reply.Filepath = append(reply.Filepath, c.mtask.filenames[mapid])
		c.mtask.mstate[mapid] = ASSIGNED

		c.mtask.lock.Unlock()

		// Check timeout
		go func() {
			time.Sleep(TIMEOUTSEC * time.Second)
			c.mtask.lock.Lock()
			defer c.mtask.lock.Unlock()

			if c.mtask.mstate[mapid] != DONE {
				c.mtask.mstate[mapid] = TIMEDOUT
				fmt.Printf("Map task %v timed out\n", mapid)
				// wake up all workers
				c.enable()
				fmt.Printf("Waking up all workers...\n")
				c.cond.Broadcast()
			}
		}()
	}
```
ËøôÊ†∑CoordinatorËøôËæπÁöÑ‰ªªÂä°ÁÆ°ÁêÜÂü∫Êú¨Â∞±ÂÆåÊàê‰∫ÜÔºå‰∏ãÈù¢ÊòØWorkerË¶ÅÂπ≤ÁöÑ‰ªªÂä°ËêΩÂÆû

workerÈ¶ñÂÖàË¶ÅÂàÜÁ±ªÊãøÂà∞ÁöÑ‰ªªÂä°Á±ªÂûãÔºå‰∏ªÊ°ÜÊû∂Â¶Ç‰∏ã

```go
//
// main/mrworker.go calls this function.
//
func Worker(mapf func(string, string) []KeyValue,
	reducef func(string, []string) string) {

	fmt.Printf("Worker %v available\n", os.Getpid())

	// Loop to require tasks from coordinator
	for {
		task := RequireTask()
		fmt.Printf("	task: %v\n", task)
		if task == nil {
			return
		}
		
		switch task.TaskType {
		case "map":
			doMap(task, mapf)

		case "reduce":
			doReduce(task, reducef)

		case "retry":
			continue

		case "wait":
			time.Sleep(3 * time.Second)
			continue

		case "exit":
			return

		default:
		}
	}

}
```

ÂæóÂà∞mapÁ±ªÂûã‰ªªÂä°ÔºåÂ∞±ÂàÜÊµÅÂéªÊâßË°å`doMap()`

ÈòÖËØªÊ°ÜÊû∂‰ª£Á†ÅÂíå`mrsequential.go`ÂêéÂèëÁé∞ÔºåmrworkerÈÄöËøá`loadPlugin()`Êù•Âä®ÊÄÅÂä†ËΩΩ‰ª•Êèí‰ª∂ÂΩ¢ÂºèÁºñËØëÁöÑ`wc.go`‰∏≠ÁöÑ`Map()`Âíå`Reduce()`ÂáΩÊï∞ÔºåËøô‰∏§‰∏™ÂáΩÊï∞Â∞±ÊòØÁî®Êà∑Â±ÇÈù¢ÂÆö‰πâÁöÑ‰ªªÂä°ÔºåÂπ∂‰ª•ÂáΩÊï∞ÂèòÈáè`mapf`Âíå`reducef`ËøîÂõûÁªôworkerÔºåworkerÂè™Ë¶ÅÂ∞Ü‰ªªÂä°Êñá‰ª∂ÂñÇÁªôÂÆÉÁÑ∂Âêé‰øùÂ≠òÂà∞ËæìÂá∫Êñá‰ª∂Â∞±Ë°å‰∫Ü

ÂèàÂõ†
> You can steal some code from mrsequential.go for reading Map input files, for sorting intermedate key/value pairs between the Map and Reduce, and for storing Reduce output in files.

ÂºÄÂÅ∑ÔºÅ

```go

func doMap(task *TaskReply, mapf func(string, string) []KeyValue) {

	file, err := os.Open(task.Filepath[0])
	if err != nil {
		log.Fatalf("Worker: cannot open %v\n", task.Filepath)
	}
	defer file.Close()

	content, err := io.ReadAll(file)
	if err != nil {
		log.Fatalf("Worker: cannot read %v\n", task.Filepath)
	}

	// Divide into nReduce intermediate files
	kva := mapf(task.Filepath[0], string(content))

	sort.Sort(ByKey(kva))

	oname := make([]string, task.NReduce)
	ofile := make([]*os.File, task.NReduce)
	enc := make([]*json.Encoder, task.NReduce)
	prefix := fmt.Sprintf("mr-%d-", task.TaskId)

	for y := 0; y < task.NReduce; y++ {
		// TODO: Replace them with temp files first
		oname[y] = fmt.Sprint(prefix, y)
		ofile[y], _ = os.Create(oname[y])
		defer ofile[y].Close()
		// fmt.Printf("worker: writing %v...\n", oname)
		enc[y] = json.NewEncoder(ofile[y])

	}
	for _, kv := range kva {
		reduceId := ihash(kv.Key) % task.NReduce
		err := enc[reduceId].Encode(&kv)
		if err != nil {
			log.Fatalf("worker: writing intermediate file failed\n")
		}
	}

	// Send notice to coordinator
	notice := new(TaskNotice)
	notice.TaskId = task.TaskId
	notice.TaskType = "map"
	notice.OFilepath = append(notice.OFilepath, oname...)
	call("Coordinator.NoticeTaskDone", notice, nil)
}
```
ÂíåmrsequentialÂÆûÁé∞‰∏çÂêåÁöÑÊòØÔºåworkerÈúÄË¶ÅÊääËæìÂá∫Êñá‰ª∂ÂàíÂàÜÊàê`nReduce`‰∏™‰∏≠Èó¥Êñá‰ª∂ÔºåËÄåÂêå‰∏Ä‰∏™Â≠óÊÆµÈúÄË¶ÅÂú®Âêå‰∏Ä‰∏™YÁºñÂè∑ÁöÑ‰∏≠Èó¥Êñá‰ª∂(mr-X-Y)‰∏≠ÔºåÂê¶Âàô‰ºöÂØºËá¥ÊúÄÁªàÁªìÊûúÂá∫Áé∞ÈáçÂ§çÂ≠óÊÆµÔºåÂõ†Ê≠§ÈúÄË¶ÅÂèñÊØè‰∏™KeyÂÅöÂìàÂ∏åÂÜçÊ®°`nReduce`ÔºåÂ∞±Áî®Ê°ÜÊû∂Êèê‰æõÁöÑ`ihash()`„ÄÇ

È¢òÁõÆÂÖ∂ÂÆûËøòË¶ÅÊ±ÇÂú®ÂΩªÂ∫ïÂÆåÊàêmap‰ªªÂä°ÂâçÂ∞ÜËæìÂá∫‰øùÂ≠òÂú®‰∏¥Êó∂Êñá‰ª∂‰∏≠ÔºåÂÆåÊàêÂêéÂÜçÈáçÂëΩÂêç
> To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use ioutil.TempFile (or os.CreateTemp if you are running Go 1.17 or later) to create a temporary file and os.Rename to atomically rename it.

‰ΩÜËøôÈáåÊàëÂÅ∑Êáí‰∫ÜÔºàË∑ëÔºâÔºåÊ≤°ÊúâËøô‰πàÂÅöÔºå‰ΩÜÊòØ‰ªéÊ≠£Á°ÆÊÄßÊù•ËÆ≤Â§ßÊ¶ÇÊ≤°‰ªÄ‰πàÈóÆÈ¢òÔºåÂõ†‰∏∫ÊàëÂú®ÂÖ®ÈÉ®Êñá‰ª∂ÂÜôÂÆåÊØïÂêéÂÜçÂèëÈÄÅÁöÑÈÄöÁü•ÔºåÂ¶ÇÊûúCoordinatorÊ≤°Êî∂Âà∞ÔºåÈÇ£‰πà‰πü‰∏ç‰ºöÂéªËÆøÈóÆËøô‰∫õ‰∏≠Èó¥Êñá‰ª∂Ôºå‰ªéËÄåÁ°Æ‰øùÂ¥©Ê∫É‰∏ÄËá¥ÊÄßÔºåÂèØ‰ª•ËÆ§‰∏∫ÊòØ‰∏ÄÁßçlog write-ahead-ruleÂêßÔºàÁ¨ëÔºâ„ÄÇ

ÔºàPSÔºö‰∏çËøáÂ¶ÇÊûúcoordinator‰πüÂ¥©Ê∫É‰∫Ü‰º∞ËÆ°Â∞±‰∏çËÉΩ‰øùËØÅ‰∏ÄËá¥ÊÄß‰∫ÜÔºå‰ΩÜÊçÆËÆ∫ÊñáÔºåcoordinatorÊåÇ‰∫ÜÂü∫Êú¨Â∞±ÂæóËÆ©Áî®Êà∑ÈáçÊñ∞ÊâßË°åÊï¥‰∏™MapReduceÔºâ

### Èò∂ÊÆµ2 - Reduce

ÂíåmapÈò∂ÊÆµ‰ª£Á†ÅÂü∫Êú¨‰∏ÄËá¥Ôºå‰∏çÂêåÁöÑÊòØ‰∏Ä‰∏™workerË¶ÅÂêåÊó∂Êé•Êî∂‰∏ÄÁªÑreduceÊñá‰ª∂ÔºåÊàëÂú®ËøôÈáåÂä†‰∫Ü‰∏Ä‰∏™Êñá‰ª∂ÂêçÂåπÈÖç

```go
//
//	Match filenames with reduceId
//
func (r *ReduceTask) matchFiles(reduceid int) []string {
	pattern := fmt.Sprintf("mr-[0-9]+-%d", reduceid)
	regex := regexp.MustCompile(pattern)

	match := []string{}

	for _, filename := range r.filenames {
		found := regex.MatchString(filename)
		if found {
			match = append(match, filename)
		}
	}
	return match
}
```
WorkerËøôËæπË¶ÅÊ≥®ÊÑèÔºåÂ¶ÇÊûúÁõ¥Êé•Â§çÂà∂mrsequential.goÁöÑ‰ª£Á†ÅÔºåÂàôË¶ÅÂú®ËØªÂèñÂÆå‰∏ÄÁªÑreduceÊñá‰ª∂ÂêéË¶ÅÂÖàÊéíÂ∫è‰∏Ä‰∏ãÈîÆÂÄºÂØπÔºåÂê¶ÂàôËæìÂá∫Êñá‰ª∂‰∏≠‰ºöÊúâÈáçÂ§çÁöÑKey


### ÊÄªÁªì
Á¨¨‰∏Ä‰∏™LabÊÄùË∑Ø‰∏äÊå∫Ê∏ÖÊô∞Êòé‰∫ÜÔºådebug‰πüÊ≤°Â§™Â§ßÁóõËã¶ÔºåÂü∫Êú¨ÂäüËÉΩÂÆûÁé∞‰∫ÜÔºåÂÖ±‰∫´Êï∞ÊçÆ‰øùÊä§Â•Ω‰∫ÜÔºåÊâÄÊúâÊµãËØïÂ∞±ËÉΩ‰∏ÄÈÅçËøáÔºåÂ∞±ÊòØÂàöÊé•Ëß¶GoÔºå‰∏äÊâãÊúâÁÇπÁîüÊ∂©ÔºåËÄå‰∏î‰ª£Á†ÅÊúâ‰∏ÄÂ§ßÂçäÈáçÂ§ç‰∫ÜÔºåÊÑüËßâÂèØ‰ª•ÂéãÁº©Â§çÁî®‰∏Ä‰∏ãÔºõÂêåÊó∂Âú®ÊúÄÂêéÊîπÊù°‰ª∂ÂèòÈáè‰ºòÂåñÁöÑÊó∂ÂÄôÂ≠óÊÆµÂÆö‰πâÂíå‰ª£Á†ÅÈÄªËæëÂíå‰πãÂâçÂÜôÁöÑÊúâÁÇπ‰∫§ÂèâÔºåÂ§ßÊäµÊòØ‰∏ÄÂºÄÂßãÊ≤°ÊÉ≥Â•ΩÁöÑÂéüÂõ†